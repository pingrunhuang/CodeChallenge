package CodeChallenge;
/*
* 小明是我司的一名优秀数据研发，每天他要处理着上千亿的数据。然而他的老板今天又给了他新的任务，要通过自然语言学习的方法，
* 去挖掘数据中的更多价值，于是小明踏上了NLP的学习之路。小明翻阅了很多书籍，初步的了解了一些NLP的算法，它们有一个共同的步骤，
* 是要做分词，然后做词频统计。现在小明已经通过一些算法，得到了一个分好词的词典，然后对于一篇给定的文章，他想知道，他得到的词典中的每个词，在文章中出现的频次。
* 值得注意的是，有许多无意义的词，往往会对文章的分析造成一些影响，所以，小明还得先过滤掉这些无意义的词。
* 此外，通常情况下，我们按先出现，先过滤的规则进行过滤(如文章’abcdefg’, 需要过滤[‘cde’, ‘bcd’], ‘bcd’先出现在了文章中，所以文章被过滤为’a efg’)。
* 但为了尽可能保持原文的完整性，对于两个过滤词(A, B)，如果A包含了B，那么要求先过滤掉B，无论是A还是B先出现(如文章’abcdefg’, 需要过滤[‘bcde’, ‘cd’]，那么文章被过滤为’ab efg’)。
* 注意，过滤之后，文章是被截断的.由于小明每天忙于数据研发，现在他想请你帮忙解决这个难题。
* 输入:
* 输入第一行是一个长度不超过100000的的字符串，代表着小明要检索的文章。 输入第二行是两个用空格隔开的，不超过100000的整数m n，分别代表需要过滤的过滤词个数，和需要统计的统计词典大小。 接下来的m行，每行是一个长度不超过100000的过滤词。所有m个词加起来总长度不超过100000。 再接下来的n行，每行是一个长度不超过100000的统计词。所有n个词加起来总长度不超过100000。 输入保证，所有的字符都在[a-z]范围
* 输出:
* 输出n行，每行一个整数，代表相应的次序的统计词在词典中出现的频数。
* 输入范例:
* bobisaopieceofssshitmostof
* 2 4
* ao
* o
* bb
* bob
* s
* ss
* 输出范例:
* 0
* 0
* 5
* 2
* */

// TODO
public class NLPProcess{

}